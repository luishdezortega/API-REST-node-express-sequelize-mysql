(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.qlite = factory());
}(this, (function () { 'use strict';

// For Node.js environment
var win = window || {
  document: global.document,
  Node: {
    ELEMENT_NODE: 1,
    TEXT_NODE: 3,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11
  }
};

var Node = win.Node;

/**
 * A element node or document node, or document fragment node?
 *
 * @export
 * @param {Node} node
 * @returns
 */
function isGoodNode(node) {
  if (!node) {
    return false;
  }

  var type = node.nodeType;

  return type === Node.ELEMENT_NODE || type === Node.DOCUMENT_NODE || type === Node.DOCUMENT_FRAGMENT_NODE;
}

var document$1 = win.document;
var RE_SIMPLE = /^(?:\.|#)?([\w-]+)$/;

/**
 * Query elements in context|document by selector.
 *
 * @export
 * @param {string} selector
 * @param {Node} context
 * @returns {Node[]}
 */
function query(selector, context) {
  if (!selector) {
    return [];
  }

  var parent = null;
  if (context) {
    if (isGoodNode(context)) {
      parent = context;
    } else if (context.length && isGoodNode(context[0])) {
      parent = context[0];
    }
  }

  parent = parent || document$1;

  function callContextMethod(context, method, name, selector) {
    if (context[method]) {
      var result = context[method](name);
      return method === 'getElementById' ? [result] : result;
    } else {
      return context.querySelectorAll(selector);
    }
  }

  if (RE_SIMPLE.test(selector)) {
    if (selector[0] === '#') {
      // ID
      return callContextMethod(parent, 'getElementById', RegExp.$1, selector);
    } else if (selector[0] === '.') {
      // ClassName
      return callContextMethod(parent, 'getElementsByClassName', RegExp.$1, selector);
    } else {
      // Tag
      return callContextMethod(parent, 'getElementsByTagName', RegExp.$1, selector);
    }
  }

  return parent.querySelectorAll(selector);
}

var support = {};

// https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createHTMLDocument
var body = document.implementation.createHTMLDocument('').body;
body.innerHTML = '<form></form><form></form>';
support.createHTMLDocument = body.childNodes.length === 2;

var RE_TAGNAME = /^\s*<(\w+|!)[^>]*>/;
var RE_SINGLETAG = /^<([a-z][^/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/;
var RE_TAGEXPANDER = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi;

// https://github.com/jquery/jquery/blob/master/src/manipulation/wrapMapMapMap.js
var wrapMap = {
  option: [1, '<select multiple="multiple">', '</select>'],
  thead: [1, '<table>', '</table>'],
  col: [2, '<table><colgroup>', '</colgroup></table>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],
  _default: [0, '', '']
};
wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

function fragment(html, context) {
  if (typeof html !== 'string') {
    return [];
  }

  if (!context) {
    if (support.createHTMLDocument) {
      context = document.implementation.createHTMLDocument('');

      var base = context.createElement('base');
      base.href = document.location.href;
      context.head.appendChild(base);
    } else {
      context = document;
    }
  }

  // Single tag match
  if (RE_SINGLETAG.test(html)) {
    return [context.createElement(RegExp.$1)];
  }

  // Use `innerHTML` to parse html fragment
  var nodes = [];
  var fragment = context.createDocumentFragment();
  var tmp = fragment.appendChild(context.createElement('div'));

  // Deserialize a standard representation
  var tag = (RE_TAGNAME.exec(html) || ['', ''])[1].toLowerCase();
  var wrap = wrapMap[tag] || wrapMap._default;
  tmp.innerHTML = '' + wrap[1] + (html.replace && html.replace(RE_TAGEXPANDER, '<$1></$2>')) + wrap[2];

  // Exclude wrap elements
  var i = wrap[0];
  while (i--) {
    tmp = tmp.lastChild;
  }

  // Add elements to result
  var children = tmp.childNodes;
  for (var _i = 0; _i < children.length; _i++) {
    nodes.push(children[_i]);
  }

  return nodes;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

function mix(Base) {
  for (var _len = arguments.length, mixins = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    mixins[_key - 1] = arguments[_key];
  }

  return mixins.reduce(function (Klass, mixin) {
    return mixin(Klass);
  }, Base);
}

// Mix every part into QLite
var QLiteBase = mix(Array);

/**
 * QLite wapper for elements
 *
 * @export
 * @class QLite
 * @extends {QLiteBase}
 */

var QLite = function (_QLiteBase) {
  inherits(QLite, _QLiteBase);

  /**
   * Creates an instance of QLite.
   * @param {string|Node|Node[]} selector
   * @param {Node|Node[]|QLite} context
   *
   * @memberOf QLite
   */
  function QLite(selector, context) {
    classCallCheck(this, QLite);

    var elems = [];

    if (!selector) {
      elems = [];
    } else {
      if (typeof selector === 'string') {
        selector = selector.trim();

        if (selector[0] === '<' && RE_TAGNAME.test(selector)) {
          // HTML Fragment
          elems = fragment(selector);
        } else {
          // selector
          elems = query(selector, context && new QLite(context));
        }
      } else if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object' && isGoodNode(selector)) {
        elems = [selector];
      } else if (selector.length && selector[0]) {
        // Array-like to QLite
        elems = selector;
      }
    }

    // Move elems to this.
    var _this = possibleConstructorReturn(this, (QLite.__proto__ || Object.getPrototypeOf(QLite)).call(this));

    var len = elems.length;
    for (var i = 0; i < len; i++) {
      if (elems[i] && isGoodNode(elems[i])) {
        _this.push(elems[i]);
      }
    }

    // DOM ready
    if (typeof selector === 'function') {
      _this.push(document);
      _this.ready && _this.ready();
    }

    // Special properties
    _this.QLite = true;
    _this.selector = selector || '';
    return _this;
  }

  return QLite;
}(QLiteBase);

/**
 * Entry qlite, like jQuery function.
 *
 * @export
 * @param {String|Node|Node[]} selector
 * @param {Node} context
 */
function qlite(selector, context) {
  return new QLite(selector, context);
}

return qlite;

})));
